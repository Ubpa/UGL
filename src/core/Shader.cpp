#include <UGL/Shader.h>

#include <iostream>
#include <fstream>
#include <sstream>

using namespace Ubpa;
using namespace Ubpa::gl;
using namespace std;

Shader::Shader(ShaderType type)
	: type{ type } { }

bool Shader::InitPath(const string& path) {
	// open files
	ifstream file;
	file.open(path);
	if (!file.is_open()) {
		cerr << "ERROR::Shader::InitPath(const string&):" << endl
			<< "    open fail" << endl
			<< "    - path: " << path << endl;
		return false;
	}
	stringstream ss;
	// read file's buffer contents into streams
	ss << file.rdbuf();
	// close file handlers
	file.close();
	// convert stream into string
	bool rst = InitSrc(ss.str());
	this->path = path; // set path after InitSrc()
	return rst;
}

bool Shader::InitSrc(const string& src) {
	Clear();

	id = gl::CreateShader(type);

	auto cstr = src.c_str();
	gl::ShaderSource(id, 1, &cstr, NULL);
	gl::CompileShader(id);

	if (!CheckCompileError()) {
		Clear();
		return false;
	}

	return true;
}

Shader::Shader(ShaderType type, const string& path)
	: type{ type }
{
	InitPath(path);
}

Shader::Shader(Shader&& shader) noexcept
	: Obj{ move(shader.id) }, path{ move(shader.path) }, type{ shader.type } {}

Shader& Shader::operator=(Shader&& shader) noexcept {
	Clear();
	id = move(shader.id);
	path = move(shader.path);
	return *this;
}

void Shader::Clear() {
	if (IsValid()) {
		gl::DeleteShader(id);
		id.Clear();
	}

	path->clear();
}

Shader::~Shader() {
	Clear();
}

void Shader::Param(ShaderParam pname, GLint* params) const {
	assert(IsValid());
	gl::GetShaderiv(id, pname, params);
}

bool Shader::CheckCompileError() const {
	assert(IsValid());

	GLint success;
	Param(ShaderParam::CompileStatus, &success);
	if (success)
		return true;

	// compile fail
	constexpr GLsizei infoLen = 512;
	GLchar infoLog[infoLen];
	gl::GetShaderInfoLog(id, infoLen, NULL, infoLog);
	cerr << "ERROR::Shader::CheckCompileError():" << endl
		<< "  compile fail" << endl
		<< "  - path: " << (path->empty() ? "generated by code" : path.get()) << endl
		<< "  - info: " << infoLog << endl;
	return false;
}
