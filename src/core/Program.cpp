#include <UGL/Program.h>

#include <iostream>

using namespace Ubpa;
using namespace Ubpa::gl;
using namespace std;


Program::Program(const GLchar* vs_src, const GLchar* fs_src) : Program{
	Shader{Shader::Type::VERTEX, vs_src},
	Shader{Shader::Type::FRAGMENT, fs_src}
} {}

Program::Program(Shader&& vs_, Shader&& fs_)
	: vs(move(vs_)), fs(move(fs_))
{
	ID = glCreateProgram();

	if (!IsValid()) {
		cerr << "ERROR::Shader::Shader(Type, const GLchar*):" << endl
			<< "  create program fail" << endl
			<< "  - vs path: " << (vs->path->empty() ? "generated by code / empty" : vs->path.get()) << endl
			<< "  - fs path: " << (fs->path->empty() ? "generated by code / empty" : vs->path.get()) << endl
			<< "  - gs path: " << (gs->path->empty() ? "generated by code / empty" : vs->path.get()) << endl;
		return;
	}

	glAttachShader(ID, vs->ID);
	glAttachShader(ID, fs->ID);

	glLinkProgram(ID);
}

bool Program::CheckLinkError() const {
	assert(IsValid());

	GLint success;
	glGetProgramiv(ID, GL_LINK_STATUS, &success);
	if (success)
		return true;

	// link fail
	constexpr GLsizei infoLen = 512;
	GLchar infoLog[infoLen];
	glGetShaderInfoLog(ID, infoLen, NULL, infoLog);
	cerr << "ERROR::Shader::CheckCompileError():" << endl
		<< "  link fail" << endl
		<< "  - vs path: " << (vs->path->empty() ? "generated by code / empty" : vs->path.get()) << endl
		<< "  - fs path: " << (fs->path->empty() ? "generated by code / empty" : vs->path.get()) << endl
		<< "  - gs path: " << (gs->path->empty() ? "generated by code / empty" : vs->path.get()) << endl
		<< "  - info: " << infoLog << endl;
	return false;
}

void Program::Use() const {
	assert(IsValid());
	glUseProgram(ID);
}
